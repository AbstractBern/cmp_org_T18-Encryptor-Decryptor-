; Listing generated by Microsoft (R) Optimizing Compiler Version 19.15.26732.1 

	TITLE	C:\Users\caleb\OneDrive - University of Texas at San Antonio\Workspace\git\cmp_org_T18-Encryptor-Decryptor-\_milestone3\Mile3\Mile1\DecryptData_Initial.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__7C512EE2_ctype@h DB 01H
__5BEBA810_basetsd@h DB 01H
__07523DAF_corecrt_memcpy_s@h DB 01H
__9F081559_corecrt_memory@h DB 01H
__9CE3A74D_corecrt_wstring@h DB 01H
__78F4D6C6_string@h DB 01H
__F7698904_guiddef@h DB 01H
__1D5C983A_winnt@h DB 01H
__4D75C327_processthreadsapi@h DB 01H
__A1C010E7_memoryapi@h DB 01H
__3CD9AC13_winerror@h DB 01H
__7D6EA4B0_winbase@h DB 01H
__1586EFC7_winuser@h DB 01H
__ED00179D_winioctl@h DB 01H
__FE874262_stdlib@h DB 01H
__22D85348_propidl@h DB 01H
__A325E0C4_oleauto@h DB 01H
__49821EBB_stralign@h DB 01H
__320E01E0_corecrt_stdio_config@h DB 01H
__BAC7FC50_corecrt_wstdio@h DB 01H
__A3797CDC_stdio@h DB 01H
__BE076D93_corecrt_wio@h DB 01H
__CEEB45E5_corecrt_io@h DB 01H
__D829B0BE_decryptdata_initial@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?decryptData@@YAHPADH@Z				; decryptData
PUBLIC	__JustMyCode_Default
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	?gptrKey@@3PAEA:DWORD				; gptrKey
EXTRN	?gptrPasswordHash@@3PAEA:DWORD			; gptrPasswordHash
EXTRN	?gdebug1@@3EA:BYTE				; gdebug1
EXTRN	?gdebug2@@3EA:BYTE				; gdebug2
EXTRN	?gNumRounds@@3HA:DWORD				; gNumRounds
EXTRN	?gDecodeTable@@3PAEA:BYTE			; gDecodeTable
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\caleb\onedrive - university of texas at san antonio\workspace\git\cmp_org_t18-encryptor-decryptor-\_milestone3\mile3\mile1\decryptdata_initial.cpp
;	COMDAT ?decryptData@@YAHPADH@Z
_TEXT	SEGMENT
_resulti$ = -8						; size = 4
_data$ = 8						; size = 4
_dataLength$ = 12					; size = 4
?decryptData@@YAHPADH@Z PROC				; decryptData, COMDAT

; 11   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 12   : 	int resulti = 0;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _resulti$[ebp], 0

; 13   : 
; 14   : 	gdebug1 = 0;					// a couple of global variables that could be used for debugging

  00025	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?gdebug1@@3EA, 0 ; gdebug1

; 15   : 	gdebug2 = 0;					// also can have a breakpoint in C code

  0002c	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?gdebug2@@3EA, 0 ; gdebug2

; 16   : 
; 17   : 	// You can not declare any local variables in C, but should use resulti to indicate any errors
; 18   : 	// Set up the stack frame and assign variables in assembly if you need to do so
; 19   : 	// access the parameters BEFORE setting up your own stack frame
; 20   : 	// Also, you cannot use a lot of global variables - work with registers
; 21   : 
; 22   : 	__asm {
; 23   :         // get parameters
; 24   :         mov esi,data

  00033	8b 75 08	 mov	 esi, DWORD PTR _data$[ebp]

; 25   :         mov edx,dataLength

  00036	8b 55 0c	 mov	 edx, DWORD PTR _dataLength$[ebp]

; 26   :         dec edx

  00039	4a		 dec	 edx

; 27   :         
; 28   :         // set up main stack frame
; 29   :         push ebp

  0003a	55		 push	 ebp

; 30   :         mov ebp,esp

  0003b	8b ec		 mov	 ebp, esp

; 31   : 
; 32   :         // store parameters in frame
; 33   :         push edx    // store dataLength

  0003d	52		 push	 edx

; 34   :         push esi    // store *data

  0003e	56		 push	 esi

; 35   :         mov edx,gNumRounds

  0003f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gNumRounds@@3HA ; gNumRounds

; 36   :         dec edx

  00045	4a		 dec	 edx

; 37   :         push edx    // store gNumRounds

  00046	52		 push	 edx

; 38   :         mov esi,gptrPasswordHash    

  00047	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gptrPasswordHash@@3PAEA ; gptrPasswordHash

; 39   :         push esi    // store *password hash

  0004d	56		 push	 esi

; 40   :         mov esi,gptrKey 

  0004e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gptrKey@@3PAEA ; gptrKey

; 41   :         push esi    // store *key

  00054	56		 push	 esi

; 42   :         xor eax,eax

  00055	33 c0		 xor	 eax, eax

; 43   :         push eax    // reserve space on stack for starting index

  00057	50		 push	 eax

; 44   :         push eax    // reserve space on stack for hop count

  00058	50		 push	 eax

; 45   : 
; 46   :         // set up for main loop
; 47   :         xor eax,eax // result storer

  00059	33 c0		 xor	 eax, eax

; 48   :         xor ebx,ebx // index

  0005b	33 db		 xor	 ebx, ebx

; 49   :         mov ecx,[ebp-12] // round

  0005d	8b 4d f4	 mov	 ecx, DWORD PTR [ebp-12]
$lbl_LOOP_ROUNDS$3:

; 50   : 
; 51   : lbl_LOOP_ROUNDS:
; 52   :         call calculateStartingIndex

  00060	e8 46 00 00 00	 call	 $calculateStartingIndex$4

; 53   :         mov [ebp-24],eax    // store result in the space we allocated previously

  00065	89 45 e8	 mov	 DWORD PTR [ebp-24], eax

; 54   :         call calculateHopCount

  00068	e8 50 00 00 00	 call	 $calculateHopCount$5

; 55   :         mov [ebp-28],eax    // store result in the space we allocated previously

  0006d	89 45 e4	 mov	 DWORD PTR [ebp-28], eax

; 56   : 
; 57   :         push ecx    // save round loop counter

  00070	51		 push	 ecx

; 58   :         xor ecx,ecx // reset for data loop counter

  00071	33 c9		 xor	 ecx, ecx
$lbl_LOOP_DATA$6:

; 59   : 
; 60   : lbl_LOOP_DATA:
; 61   :         // data decryption
; 62   :         call stepA

  00073	e8 96 00 00 00	 call	 $stepA$7

; 63   :         call stepB

  00078	e8 b1 00 00 00	 call	 $stepB$8

; 64   :         call stepE

  0007d	e8 e2 00 00 00	 call	 $stepE$9

; 65   :         call stepD

  00082	e8 c4 00 00 00	 call	 $stepD$10

; 66   :         call stepC

  00087	e8 b2 00 00 00	 call	 $stepC$11

; 67   :         call xorByte

  0008c	e8 4c 00 00 00	 call	 $xorByte$12

; 68   :         call incrementIndex

  00091	e8 5e 00 00 00	 call	 $incrementIndex$13

; 69   : 
; 70   :         // data loop logic
; 71   :         cmp ecx,[ebp-4]

  00096	3b 4d fc	 cmp	 ecx, DWORD PTR [ebp-4]

; 72   :         je lbl_EXIT_LOOP_DATA

  00099	74 03		 je	 SHORT $lbl_EXIT_LOOP_DATA$14

; 73   :         inc ecx

  0009b	41		 inc	 ecx

; 74   :         jmp lbl_LOOP_DATA

  0009c	eb d5		 jmp	 SHORT $lbl_LOOP_DATA$6
$lbl_EXIT_LOOP_DATA$14:

; 75   : 
; 76   : lbl_EXIT_LOOP_DATA:
; 77   :         pop ecx

  0009e	59		 pop	 ecx

; 78   :         // end data loop
; 79   : 
; 80   :         // round loop logic
; 81   :         cmp ecx,0

  0009f	83 f9 00	 cmp	 ecx, 0

; 82   :         je lbl_EXIT_LOOP_ROUNDS

  000a2	0f 84 de 00 00
	00		 je	 $lbl_EXIT_LOOP_ROUNDS$15

; 83   :         dec ecx

  000a8	49		 dec	 ecx

; 84   :         jmp lbl_LOOP_ROUNDS

  000a9	eb b5		 jmp	 SHORT $lbl_LOOP_ROUNDS$3
$calculateStartingIndex$4:

; 85   :         
; 86   : //                      FUNCTIONS
; 87   : calculateStartingIndex:
; 88   :         // calc starting index
; 89   :         mov esi,[ebp-16]                    // get passHash

  000ab	8b 75 f0	 mov	 esi, DWORD PTR [ebp-16]

; 90   :         xor eax,eax

  000ae	33 c0		 xor	 eax, eax

; 91   :         mov al,byte ptr[esi+ecx*4]          // eax = gPasswordHash[0+round*4]

  000b0	8a 04 8e	 mov	 al, BYTE PTR [esi+ecx*4]

; 92   :         sal eax,8                           // eax*256

  000b3	c1 e0 08	 shl	 eax, 8

; 93   :         inc esi

  000b6	46		 inc	 esi

; 94   :         mov bl, byte ptr[esi + ecx * 4]     // ebx = gPasswordHash[1+round*4]

  000b7	8a 1c 8e	 mov	 bl, BYTE PTR [esi+ecx*4]

; 95   :         add eax,ebx

  000ba	03 c3		 add	 eax, ebx

; 96   :         ret

  000bc	c3		 ret	 0
$calculateHopCount$5:

; 97   :         // end calculateStartingIndex
; 98   : 
; 99   : calculateHopCount:
; 100  :         // calc hop count
; 101  :         mov esi,[ebp-16]

  000bd	8b 75 f0	 mov	 esi, DWORD PTR [ebp-16]

; 102  :         add esi,2

  000c0	83 c6 02	 add	 esi, 2

; 103  :         xor eax,eax

  000c3	33 c0		 xor	 eax, eax

; 104  :         mov al,byte ptr[esi+ecx*4]

  000c5	8a 04 8e	 mov	 al, BYTE PTR [esi+ecx*4]

; 105  :         sal eax,8

  000c8	c1 e0 08	 shl	 eax, 8

; 106  :         inc esi

  000cb	46		 inc	 esi

; 107  :         mov bl,byte ptr[esi+ecx*4]

  000cc	8a 1c 8e	 mov	 bl, BYTE PTR [esi+ecx*4]

; 108  :         add eax,ebx

  000cf	03 c3		 add	 eax, ebx

; 109  :         // fix hop count if necessary
; 110  :         cmp eax,0

  000d1	83 f8 00	 cmp	 eax, 0

; 111  :         je lbl_FIX_HOP  // fix

  000d4	74 01		 je	 SHORT $lbl_FIX_HOP$16

; 112  :         ret             // dont fix

  000d6	c3		 ret	 0
$lbl_FIX_HOP$16:

; 113  : 
; 114  :     lbl_FIX_HOP:
; 115  :         mov eax,0xFFFF

  000d7	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH

; 116  :         ret

  000dc	c3		 ret	 0
$xorByte$12:

; 117  :         // end calculateHopCount
; 118  : 
; 119  : xorByte:
; 120  :         push ebx

  000dd	53		 push	 ebx

; 121  :         xor ebx,ebx

  000de	33 db		 xor	 ebx, ebx

; 122  :         mov ebx,[ebp-24]    // get index from stack frame

  000e0	8b 5d e8	 mov	 ebx, DWORD PTR [ebp-24]

; 123  :         mov esi,[ebp-8]     // get *data from stack frame

  000e3	8b 75 f8	 mov	 esi, DWORD PTR [ebp-8]

; 124  :         mov edi,[ebp-20]    // get *gKey from stack frame

  000e6	8b 7d ec	 mov	 edi, DWORD PTR [ebp-20]

; 125  :         mov al,byte ptr[edi+ebx]   // al = gKey[index]

  000e9	8a 04 1f	 mov	 al, BYTE PTR [edi+ebx]

; 126  :         xor al,byte ptr[esi+ecx]   // al = al ^ data[x]

  000ec	32 04 0e	 xor	 al, BYTE PTR [esi+ecx]

; 127  :         mov byte ptr[esi+ecx],al   // update data buffer byte

  000ef	88 04 0e	 mov	 BYTE PTR [esi+ecx], al

; 128  :         pop ebx

  000f2	5b		 pop	 ebx

; 129  :         ret

  000f3	c3		 ret	 0
$incrementIndex$13:

; 130  : 
; 131  : incrementIndex:
; 132  :         mov eax,[ebp-24]    // eax = index

  000f4	8b 45 e8	 mov	 eax, DWORD PTR [ebp-24]

; 133  :         add eax,[ebp-28]    // index += hopcount

  000f7	03 45 e4	 add	 eax, DWORD PTR [ebp-28]

; 134  :         // fix index if necessary
; 135  :         cmp eax,65537

  000fa	3d 01 00 01 00	 cmp	 eax, 65537		; 00010001H

; 136  :         jae lbl_FIX_INDEX   // fix

  000ff	73 04		 jae	 SHORT $lbl_FIX_INDEX$17

; 137  :         mov [ebp-24],eax    // set new index

  00101	89 45 e8	 mov	 DWORD PTR [ebp-24], eax

; 138  :         ret                 // dont fix

  00104	c3		 ret	 0
$lbl_FIX_INDEX$17:

; 139  : 
; 140  :     lbl_FIX_INDEX:
; 141  :         sub eax,65537

  00105	2d 01 00 01 00	 sub	 eax, 65537		; 00010001H

; 142  :         mov [ebp-24],eax    // set new index

  0010a	89 45 e8	 mov	 DWORD PTR [ebp-24], eax

; 143  :         ret

  0010d	c3		 ret	 0
$stepA$7:

; 144  : 
; 145  : stepA:		
; 146  :         push ebx

  0010e	53		 push	 ebx

; 147  :         xor ebx,ebx

  0010f	33 db		 xor	 ebx, ebx

; 148  :         mov esi,[ebp-8]             // get *data

  00111	8b 75 f8	 mov	 esi, DWORD PTR [ebp-8]

; 149  : 		mov al,byte ptr[esi+ecx]	// get data[x]		

  00114	8a 04 0e	 mov	 al, BYTE PTR [esi+ecx]

; 150  :         xor ebx,ebx

  00117	33 db		 xor	 ebx, ebx

; 151  : 		mov bh,0xAA					// 0xAA has all even bits 1 and odd 0,								

  00119	b7 aa		 mov	 bh, -86			; ffffffaaH

; 152  : 									// bitwise and with this value will result in showing all even bits	
; 153  : 		and bh,al					// bh is now all the even bits of our byte							

  0011b	22 f8		 and	 bh, al

; 154  : 		mov bl,0x55					// 0x55 has all even bits 0 and odd 1,								

  0011d	b3 55		 mov	 bl, 85			; 00000055H

; 155  : 									// bitwise and with this value will result in showing all odd bits		
; 156  : 		and bl,al					// bl is not all the odd bits of our byte							

  0011f	22 d8		 and	 bl, al

; 157  : 		shr bh,1					// shift all even bits right 1 time	

  00121	d0 ef		 shr	 bh, 1

; 158  : 		shl bl,1					// shift all odd bits left 1 time										

  00123	d0 e3		 shl	 bl, 1

; 159  : 		or bl,bh					// combine them back together									

  00125	0a df		 or	 bl, bh

; 160  : 		mov al,bl                   // al is now out byte with even and odd bits swapped

  00127	8a c3		 mov	 al, bl

; 161  :         mov byte ptr[esi+ecx],al    // update data buffer byte

  00129	88 04 0e	 mov	 BYTE PTR [esi+ecx], al

; 162  :         pop ebx

  0012c	5b		 pop	 ebx

; 163  :         ret

  0012d	c3		 ret	 0
$stepB$8:

; 164  : 
; 165  : stepB:
; 166  :         push ebx

  0012e	53		 push	 ebx

; 167  :         xor ebx,ebx

  0012f	33 db		 xor	 ebx, ebx

; 168  : 		mov esi,[ebp-8]             // get *data

  00131	8b 75 f8	 mov	 esi, DWORD PTR [ebp-8]

; 169  :         mov al, byte ptr[esi+ecx]	// get data[x]	

  00134	8a 04 0e	 mov	 al, BYTE PTR [esi+ecx]

; 170  : 		xor al,00111100b			// this inverts the middle 4 bits			

  00137	34 3c		 xor	 al, 60			; 0000003cH

; 171  : 		mov byte ptr[esi+ecx],al    // update data buffer byte

  00139	88 04 0e	 mov	 BYTE PTR [esi+ecx], al

; 172  : 	    pop ebx

  0013c	5b		 pop	 ebx

; 173  :         ret

  0013d	c3		 ret	 0
$stepC$11:

; 174  : 
; 175  : stepC:
; 176  : 		mov esi,[ebp-8]             // get *data

  0013e	8b 75 f8	 mov	 esi, DWORD PTR [ebp-8]

; 177  :         mov al,byte ptr[esi+ecx]	// get data[x]

  00141	8a 04 0e	 mov	 al, BYTE PTR [esi+ecx]

; 178  :         ror al,4                    // rotate 4 to right

  00144	c0 c8 04	 ror	 al, 4

; 179  :         mov byte ptr[esi+ecx],al    // update data buffer byte

  00147	88 04 0e	 mov	 BYTE PTR [esi+ecx], al

; 180  :         ret

  0014a	c3		 ret	 0
$stepD$10:

; 181  : 
; 182  : stepD:
; 183  :         mov esi,[ebp-8]             // get *data

  0014b	8b 75 f8	 mov	 esi, DWORD PTR [ebp-8]

; 184  :         xor eax,eax

  0014e	33 c0		 xor	 eax, eax

; 185  :         push ebx

  00150	53		 push	 ebx

; 186  :         xor ebx,ebx

  00151	33 db		 xor	 ebx, ebx

; 187  :         mov al,byte ptr[esi+ecx]	// get data[x]

  00153	8a 04 0e	 mov	 al, BYTE PTR [esi+ecx]

; 188  : 		lea edi, gDecodeTable		// put the address of the first byte of gEncodeTable into esi

  00156	8d 3d 00 00 00
	00		 lea	 edi, OFFSET ?gDecodeTable@@3PAEA

; 189  : 		mov bl, byte ptr[edi+eax]	// copy the value at the index al from gEncodeTable (gEncodeTable[al])

  0015c	8a 1c 07	 mov	 bl, BYTE PTR [edi+eax]

; 190  :         mov byte ptr[esi + ecx],bl  // update data buffer byte

  0015f	88 1c 0e	 mov	 BYTE PTR [esi+ecx], bl

; 191  :         pop ebx

  00162	5b		 pop	 ebx

; 192  :         ret

  00163	c3		 ret	 0
$stepE$9:

; 193  : 
; 194  : stepE: 
; 195  : 		push ebx					// save old ebx value

  00164	53		 push	 ebx

; 196  : 		push edx					// save old ecx value

  00165	52		 push	 edx

; 197  :         xor eax,eax

  00166	33 c0		 xor	 eax, eax

; 198  :         mov esi,[ebp-8]             // get *data

  00168	8b 75 f8	 mov	 esi, DWORD PTR [ebp-8]

; 199  :         mov al,byte ptr[esi+ecx]	// get data[x]

  0016b	8a 04 0e	 mov	 al, BYTE PTR [esi+ecx]

; 200  : 		xor ebx,ebx					// set ebx to 0, will be our counter

  0016e	33 db		 xor	 ebx, ebx

; 201  : 		xor edx,edx					// set ecx to 0, will be the new reversed value

  00170	33 d2		 xor	 edx, edx

; 202  : 		jmp lbl_ELOOP				// start looping

  00172	eb 00		 jmp	 SHORT $lbl_ELOOP$18
$lbl_ELOOP$18:

; 203  : 			
; 204  : 	lbl_ELOOP:
; 205  : 			shl al,1					// shift the right most bit into the carry

  00174	d0 e0		 shl	 al, 1

; 206  : 			rcr dl,1					// rotate the carry into dl

  00176	d0 da		 rcr	 dl, 1

; 207  : 			cmp ebx,7					// compare counter to 7

  00178	83 fb 07	 cmp	 ebx, 7

; 208  : 			je lbl_EEND					// if counter is 7 end the loop

  0017b	74 03		 je	 SHORT $lbl_EEND$19

; 209  : 			inc ebx						// else increment count

  0017d	43		 inc	 ebx

; 210  : 			jmp lbl_ELOOP				// and keep looping

  0017e	eb f4		 jmp	 SHORT $lbl_ELOOP$18
$lbl_EEND$19:

; 211  : 
; 212  : 	lbl_EEND:
; 213  : 			mov byte ptr[esi + ecx],dl  // update data buffer byte

  00180	88 14 0e	 mov	 BYTE PTR [esi+ecx], dl

; 214  : 			pop edx						// restore ecx

  00183	5a		 pop	 edx

; 215  : 			pop ebx						// restore ebx

  00184	5b		 pop	 ebx

; 216  : 			ret							// return

  00185	c3		 ret	 0
$lbl_EXIT_LOOP_ROUNDS$15:

; 217  : 
; 218  : //                      END FUNCTIONS
; 219  : 
; 220  : lbl_EXIT_LOOP_ROUNDS:
; 221  :         // end round loop, end assembly
; 222  :         add esp,28

  00186	83 c4 1c	 add	 esp, 28			; 0000001cH

; 223  :         pop ebp

  00189	5d		 pop	 ebp

; 224  : 	}
; 225  : 
; 226  : 	return resulti;

  0018a	8b 45 f8	 mov	 eax, DWORD PTR _resulti$[ebp]

; 227  : }

  0018d	5f		 pop	 edi
  0018e	5e		 pop	 esi
  0018f	5b		 pop	 ebx
  00190	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00196	3b ec		 cmp	 ebp, esp
  00198	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0019d	8b e5		 mov	 esp, ebp
  0019f	5d		 pop	 ebp
  001a0	c3		 ret	 0
?decryptData@@YAHPADH@Z ENDP				; decryptData
_TEXT	ENDS
END
