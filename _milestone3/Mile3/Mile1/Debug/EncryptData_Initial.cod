; Listing generated by Microsoft (R) Optimizing Compiler Version 19.15.26732.1 

	TITLE	C:\Users\caleb\OneDrive - University of Texas at San Antonio\Workspace\git\cmp_org_T18-Encryptor-Decryptor-\_milestone3\Mile3\Mile1\EncryptData_Initial.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__7C512EE2_ctype@h DB 01H
__5BEBA810_basetsd@h DB 01H
__07523DAF_corecrt_memcpy_s@h DB 01H
__9F081559_corecrt_memory@h DB 01H
__9CE3A74D_corecrt_wstring@h DB 01H
__78F4D6C6_string@h DB 01H
__F7698904_guiddef@h DB 01H
__1D5C983A_winnt@h DB 01H
__4D75C327_processthreadsapi@h DB 01H
__A1C010E7_memoryapi@h DB 01H
__3CD9AC13_winerror@h DB 01H
__7D6EA4B0_winbase@h DB 01H
__1586EFC7_winuser@h DB 01H
__ED00179D_winioctl@h DB 01H
__FE874262_stdlib@h DB 01H
__22D85348_propidl@h DB 01H
__A325E0C4_oleauto@h DB 01H
__49821EBB_stralign@h DB 01H
__320E01E0_corecrt_stdio_config@h DB 01H
__BAC7FC50_corecrt_wstdio@h DB 01H
__A3797CDC_stdio@h DB 01H
__BE076D93_corecrt_wio@h DB 01H
__CEEB45E5_corecrt_io@h DB 01H
__C361D12A_encryptdata_initial@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?encryptData@@YAHPADH@Z				; encryptData
PUBLIC	__JustMyCode_Default
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	?gptrKey@@3PAEA:DWORD				; gptrKey
EXTRN	?gptrPasswordHash@@3PAEA:DWORD			; gptrPasswordHash
EXTRN	?gdebug1@@3EA:BYTE				; gdebug1
EXTRN	?gdebug2@@3EA:BYTE				; gdebug2
EXTRN	?gNumRounds@@3HA:DWORD				; gNumRounds
EXTRN	?gEncodeTable@@3PAEA:BYTE			; gEncodeTable
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\caleb\onedrive - university of texas at san antonio\workspace\git\cmp_org_t18-encryptor-decryptor-\_milestone3\mile3\mile1\encryptdata_initial.cpp
;	COMDAT ?encryptData@@YAHPADH@Z
_TEXT	SEGMENT
_resulti$ = -8						; size = 4
_data$ = 8						; size = 4
_dataLength$ = 12					; size = 4
?encryptData@@YAHPADH@Z PROC				; encryptData, COMDAT

; 11   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 12   : 	int resulti = 0;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _resulti$[ebp], 0

; 13   : 
; 14   : 	gdebug1 = 0;					// a couple of global variables that could be used for debugging

  00025	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?gdebug1@@3EA, 0 ; gdebug1

; 15   : 	gdebug2 = 0;					// also can have a breakpoint in C code

  0002c	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?gdebug2@@3EA, 0 ; gdebug2

; 16   : 
; 17   : 	// You can not declare any local variables in C, but should use resulti to indicate any errors
; 18   : 	// Set up the stack frame and assign variables in assembly if you need to do so
; 19   : 	// access the parameters BEFORE setting up your own stack frame
; 20   : 	// Also, you cannot use a lot of global variables - work with registers
; 21   : 
; 22   : 	__asm {
; 23   : 
; 24   : 			xor eax,eax	//	result storer

  00033	33 c0		 xor	 eax, eax

; 25   : 			xor ebx,ebx //	starting index (only in scope of loop-rounds)

  00035	33 db		 xor	 ebx, ebx

; 26   : 			xor ecx,ecx	//	"round" counter 0 -> gNumRounds

  00037	33 c9		 xor	 ecx, ecx
$lbl_LOOP_ROUNDS$3:

; 27   : 			
; 28   : lbl_LOOP_ROUNDS:							//		BEGIN LOOP-ROUND
; 29   : 
; 30   : 			push ecx						// parameter "round"

  00039	51		 push	 ecx

; 31   : 			call calculateStartingIndex		//		CALCULATE STARTING INDEX[ROUND]

  0003a	e8 2a 00 00 00	 call	 $calculateStartingIndex$4

; 32   : 			mov ebx,eax						// move result of call to ebx

  0003f	8b d8		 mov	 ebx, eax

; 33   : 			call calculateHopCount			//		CALCULATE HOP COUNT[ROUND]			note: uses same parameter as previous call

  00041	e8 47 00 00 00	 call	 $calculateHopCount$5

; 34   : 			mov edx,eax						// move result of call to edx

  00046	8b d0		 mov	 edx, eax

; 35   : 			pop ecx

  00048	59		 pop	 ecx

; 36   : 
; 37   : 			push ecx						// parameter "round"		[5th]

  00049	51		 push	 ecx

; 38   : 			push dataLength					// parameter dataLength		[4th]

  0004a	ff 75 0c	 push	 DWORD PTR _dataLength$[ebp]

; 39   : 			push data						// parameter data buffer	[3rd]

  0004d	ff 75 08	 push	 DWORD PTR _data$[ebp]

; 40   : 			push ebx						// index					[2nd]

  00050	53		 push	 ebx

; 41   : 			push edx						// hop count				[1st]

  00051	52		 push	 edx

; 42   : 			call setupDataLoop				//		LOOP THROUGH ENTIRE DATA BUFFER BYTE by BYTE

  00052	e8 6a 00 00 00	 call	 $setupDataLoop$6

; 43   : 			add esp,10

  00057	83 c4 0a	 add	 esp, 10			; 0000000aH

; 44   : 			
; 45   : 			cmp ecx,gNumRounds				//		LOOP-ROUND LOGIC

  0005a	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?gNumRounds@@3HA ; gNumRounds

; 46   : 			je lbl_EXIT_ROUNDS				// end loop

  00060	0f 84 2f 01 00
	00		 je	 $lbl_EXIT_ROUNDS$7

; 47   : 			inc ecx							// rounds++

  00066	41		 inc	 ecx

; 48   : 			jmp lbl_LOOP_ROUNDS				// loop again

  00067	eb d0		 jmp	 SHORT $lbl_LOOP_ROUNDS$3
$calculateStartingIndex$4:

; 49   : 			
; 50   : calculateStartingIndex:						//		CALCULATE STARTING INDEX
; 51   : 			push ebp						//

  00069	55		 push	 ebp

; 52   : 			mov ebp,esp						//

  0006a	8b ec		 mov	 ebp, esp

; 53   : 			push ebx						//											note: not pushing eax here because we are returning result via eax

  0006c	53		 push	 ebx

; 54   : 			push ecx						//

  0006d	51		 push	 ecx

; 55   : 			push esi						//

  0006e	56		 push	 esi

; 56   : 
; 57   : 			mov al,byte ptr[ebp+8]			// get parameter "rounds"

  0006f	8a 45 08	 mov	 al, BYTE PTR [ebp+8]

; 58   : 			mov esi,gptrPasswordHash		// copy passwordHash address

  00072	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gptrPasswordHash@@3PAEA ; gptrPasswordHash

; 59   : 			mov bl,byte ptr[esi+eax*4]		// ebx = passwordHash[0 + "rounds" * 4]

  00078	8a 1c 86	 mov	 bl, BYTE PTR [esi+eax*4]

; 60   : 			sal ebx,8						// ebx = ebx * 256

  0007b	c1 e3 08	 shl	 ebx, 8

; 61   : 			inc esi							// increment passwordHash index

  0007e	46		 inc	 esi

; 62   : 			mov cl,byte ptr[esi+eax*4]		// copy passwordHash byte into cl

  0007f	8a 0c 86	 mov	 cl, BYTE PTR [esi+eax*4]

; 63   : 			add bx,cx						// ebx + passwordHash[1 + "rounds" * 4]

  00082	66 03 d9	 add	 bx, cx

; 64   : 
; 65   : 			mov ax,bx						// copy result into ax to return

  00085	66 8b c3	 mov	 ax, bx

; 66   : 			pop esi							//

  00088	5e		 pop	 esi

; 67   : 			pop ecx							//

  00089	59		 pop	 ecx

; 68   : 			pop ebx							//

  0008a	5b		 pop	 ebx

; 69   : 			pop ebp							//

  0008b	5d		 pop	 ebp

; 70   : 			ret								//		END CALCULATE STARTING INDEX

  0008c	c3		 ret	 0
$calculateHopCount$5:

; 71   : 
; 72   : calculateHopCount:							//		CALCULATE HOP COUNT
; 73   : 			push ebp						//

  0008d	55		 push	 ebp

; 74   : 			mov ebp,esp						//

  0008e	8b ec		 mov	 ebp, esp

; 75   : 			push esi						//											note: not pushing eax here because we are returning result via eax

  00090	56		 push	 esi

; 76   : 			push ebx						//

  00091	53		 push	 ebx

; 77   : 			push ecx						//

  00092	51		 push	 ecx

; 78   : 
; 79   : 			xor eax,eax						//

  00093	33 c0		 xor	 eax, eax

; 80   : 			mov al,byte ptr[ebp+8]			// get parameter "rounds"

  00095	8a 45 08	 mov	 al, BYTE PTR [ebp+8]

; 81   : 			mov esi,gptrPasswordHash		//

  00098	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gptrPasswordHash@@3PAEA ; gptrPasswordHash

; 82   : 			add esi,2						//

  0009e	83 c6 02	 add	 esi, 2

; 83   : 			mov bl,byte ptr[esi+eax*4]		// ebx = passwordHash[2 + "rounds" * 4]

  000a1	8a 1c 86	 mov	 bl, BYTE PTR [esi+eax*4]

; 84   : 			sal ebx,8						// ebx = ebx * 256

  000a4	c1 e3 08	 shl	 ebx, 8

; 85   : 			inc esi							//

  000a7	46		 inc	 esi

; 86   : 			mov cl, byte ptr[esi + eax * 4]	// copy passwordHash byte into cl

  000a8	8a 0c 86	 mov	 cl, BYTE PTR [esi+eax*4]

; 87   : 			add bx,cx						// ebx = ebx + passwordHash[3 + "rounds" * 4]

  000ab	66 03 d9	 add	 bx, cx

; 88   : 			cmp ebx,0						//

  000ae	83 fb 00	 cmp	 ebx, 0

; 89   : 			je fixHopCount					//

  000b1	74 02		 je	 SHORT $fixHopCount$8

; 90   : 			jmp lbl_EXIT_HOP_COUNT			//

  000b3	eb 04		 jmp	 SHORT $lbl_EXIT_HOP_COUNT$9
$fixHopCount$8:

; 91   : 
; 92   : 		fixHopCount:						//		FIX HOP COUNT
; 93   : 			mov bx,0xFFFF					// set "hop count" to 0

  000b5	66 bb ff ff	 mov	 bx, -1
$lbl_EXIT_HOP_COUNT$9:

; 94   : 
; 95   : 		lbl_EXIT_HOP_COUNT:					//		EXIT HOP COUNT
; 96   : 			mov ax,bx						// copy result into ex to return

  000b9	66 8b c3	 mov	 ax, bx

; 97   : 			pop ecx							//

  000bc	59		 pop	 ecx

; 98   : 			pop ebx							//

  000bd	5b		 pop	 ebx

; 99   : 			pop esi							//

  000be	5e		 pop	 esi

; 100  : 			pop ebp							//

  000bf	5d		 pop	 ebp

; 101  : 			ret								//		END CALCULATE HOP COUNT

  000c0	c3		 ret	 0
$setupDataLoop$6:

; 102  : 			
; 103  : setupDataLoop:								//		SETUP FOR DATA LOOP
; 104  : 			push ebp						//	stack frame quick reference:

  000c1	55		 push	 ebp

; 105  : 			mov ebp,esp						//			ebp+8	=	hop count			eax	= returner

  000c2	8b ec		 mov	 ebp, esp

; 106  : 			push eax						//			ebp+12	=	index				ebx = general use

  000c4	50		 push	 eax

; 107  : 			push ebx						//			ebp+16	=	data buffer			ecx = counter

  000c5	53		 push	 ebx

; 108  : 			push ecx						//			ebp+20	=	data length			edi = keyfile starting address

  000c6	51		 push	 ecx

; 109  : 			push edi						//			ebp+24	=	round				esi = databuffer starting address

  000c7	57		 push	 edi

; 110  : 			push esi						//											edx = index

  000c8	56		 push	 esi

; 111  : 			push edx						//				

  000c9	52		 push	 edx

; 112  : 
; 113  : 			xor edx,edx

  000ca	33 d2		 xor	 edx, edx

; 114  : 			xor ecx,ecx						// counter for loop

  000cc	33 c9		 xor	 ecx, ecx

; 115  : 			mov edx,[ebp+12]

  000ce	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]

; 116  : 			mov edi,gptrKey					// keyfile address

  000d1	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?gptrKey@@3PAEA ; gptrKey

; 117  : 			mov esi,[ebp+16]				// data buffer address

  000d7	8b 75 10	 mov	 esi, DWORD PTR [ebp+16]
$lbl_DATA_LOOP$10:

; 118  : 
; 119  : lbl_DATA_LOOP:								//		LOOP THROUGH DATA BYTE BY BYTE
; 120  : 			
; 121  : 			call xorByte					// call xorByte

  000da	e8 5b 00 00 00	 call	 $xorByte$11

; 122  : 			mov byte ptr[esi+ecx],al		// store replace data byte

  000df	88 04 0e	 mov	 BYTE PTR [esi+ecx], al

; 123  : 
; 124  : 			add edx,[ebp+8]					// index += hop count

  000e2	03 55 08	 add	 edx, DWORD PTR [ebp+8]

; 125  : 
; 126  : 			cmp edx,65537					// if (index >= 65537)

  000e5	81 fa 01 00 01
	00		 cmp	 edx, 65537		; 00010001H

; 127  : 			jae lbl_FIX_INDEX				// index -= 65537

  000eb	73 02		 jae	 SHORT $lbl_FIX_INDEX$12

; 128  : 			jmp lbl_DO_STEPS			    // nothing

  000ed	eb 06		 jmp	 SHORT $lbl_DO_STEPS$13
$lbl_FIX_INDEX$12:

; 129  : 
; 130  : 		lbl_FIX_INDEX:						//		FIX THE INDEX
; 131  : 			sub edx,65537					//

  000ef	81 ea 01 00 01
	00		 sub	 edx, 65537		; 00010001H
$lbl_DO_STEPS$13:

; 132  : 
; 133  : 		lbl_DO_STEPS:						//		DO 5 STEPS
; 134  : 			call stepC						//	C

  000f5	e8 66 00 00 00	 call	 $stepC$14

; 135  : 			mov gdebug1,al

  000fa	a2 00 00 00 00	 mov	 BYTE PTR ?gdebug1@@3EA, al ; gdebug1

; 136  : 			call stepD						//	D

  000ff	e8 60 00 00 00	 call	 $stepD$15

; 137  : 			mov gdebug1, al

  00104	a2 00 00 00 00	 mov	 BYTE PTR ?gdebug1@@3EA, al ; gdebug1

; 138  : 			call stepE						//	E

  00109	e8 6e 00 00 00	 call	 $stepE$16

; 139  : 			mov gdebug1,al

  0010e	a2 00 00 00 00	 mov	 BYTE PTR ?gdebug1@@3EA, al ; gdebug1

; 140  : 			call stepB						//	B

  00113	e8 45 00 00 00	 call	 $stepB$17

; 141  : 			mov gdebug1, al

  00118	a2 00 00 00 00	 mov	 BYTE PTR ?gdebug1@@3EA, al ; gdebug1

; 142  : 			call stepA						//	A

  0011d	e8 28 00 00 00	 call	 $stepA$18

; 143  : 			mov gdebug1,al

  00122	a2 00 00 00 00	 mov	 BYTE PTR ?gdebug1@@3EA, al ; gdebug1

; 144  : 			mov byte ptr[esi+ecx],al		//

  00127	88 04 0e	 mov	 BYTE PTR [esi+ecx], al

; 145  : 
; 146  : 			cmp ecx,[ebp+20]				// compare counter with data length

  0012a	3b 4d 14	 cmp	 ecx, DWORD PTR [ebp+20]

; 147  : 			je lbl_EXIT_DATA_LOOP			// end loop if counter = data length

  0012d	74 03		 je	 SHORT $lbl_EXIT_DATA_LOOP$19

; 148  : 			inc ecx							// increment counter

  0012f	41		 inc	 ecx

; 149  : 			jmp lbl_DATA_LOOP				// else keep looping

  00130	eb a8		 jmp	 SHORT $lbl_DATA_LOOP$10
$lbl_EXIT_DATA_LOOP$19:

; 150  : 
; 151  : 
; 152  : lbl_EXIT_DATA_LOOP:							//		EXIT DATA LOOP
; 153  : 			pop edx

  00132	5a		 pop	 edx

; 154  : 			pop esi

  00133	5e		 pop	 esi

; 155  : 			pop edi

  00134	5f		 pop	 edi

; 156  : 			pop ecx

  00135	59		 pop	 ecx

; 157  : 			pop ebx

  00136	5b		 pop	 ebx

; 158  : 			pop eax

  00137	58		 pop	 eax

; 159  : 			pop ebp

  00138	5d		 pop	 ebp

; 160  : 			ret								//		END DATA LOOP

  00139	c3		 ret	 0
$xorByte$11:

; 161  : 			
; 162  : xorByte:
; 163  : 			push ebx

  0013a	53		 push	 ebx

; 164  : 			push edx

  0013b	52		 push	 edx

; 165  : 			mov bl,byte ptr[esi+ecx]

  0013c	8a 1c 0e	 mov	 bl, BYTE PTR [esi+ecx]

; 166  : 			mov edx,[ebp+12]

  0013f	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]

; 167  : 			xor bl,byte ptr[edi+edx]

  00142	32 1c 17	 xor	 bl, BYTE PTR [edi+edx]

; 168  : 			mov al,bl

  00145	8a c3		 mov	 al, bl

; 169  : 			pop edx

  00147	5a		 pop	 edx

; 170  : 			pop ebx

  00148	5b		 pop	 ebx

; 171  : 			ret

  00149	c3		 ret	 0
$stepA$18:

; 172  : 
; 173  : stepA:									//									A																			
; 174  : 			push ecx					// save old ecx value															

  0014a	51		 push	 ecx

; 175  : 			mov ch,0xAA					// 0xAA has all even bits 1 and odd 0,										

  0014b	b5 aa		 mov	 ch, -86			; ffffffaaH

; 176  : 										// bitwise and with this value will result in showing all even bits		
; 177  : 			and ch,al					// ch is now all the even bits of our byte								

  0014d	22 e8		 and	 ch, al

; 178  : 			mov cl,0x55					// 0x55 has all even bits 0 and odd 1,									

  0014f	b1 55		 mov	 cl, 85			; 00000055H

; 179  : 										// bitwise and with this value will result in showing all odd bits	
; 180  : 			and cl,al					// cl is not all the odd bits of our byte									

  00151	22 c8		 and	 cl, al

; 181  : 			shr ch,1					// shift all even bits right 1 time									

  00153	d0 ed		 shr	 ch, 1

; 182  : 			shl cl,1					// shift all odd bits left 1 time								

  00155	d0 e1		 shl	 cl, 1

; 183  : 			or cl,ch					// combine them back together									

  00157	0a cd		 or	 cl, ch

; 184  : 			mov al,cl                   // al is now our byte with even and odd bits swapped											

  00159	8a c1		 mov	 al, cl

; 185  : 			pop ecx						// restore ecx																															

  0015b	59		 pop	 ecx

; 186  : 			ret							// return															

  0015c	c3		 ret	 0
$stepB$17:

; 187  : 
; 188  : stepB:									//									B										
; 189  : 			xor al,00111100b			// this inverts the middle 4 bits										

  0015d	34 3c		 xor	 al, 60			; 0000003cH

; 190  : 			ret							// return									

  0015f	c3		 ret	 0
$stepC$14:

; 191  : 
; 192  : stepC:									//									C			
; 193  : 			ror al,4					// rotate 4 to the right							

  00160	c0 c8 04	 ror	 al, 4

; 194  : 			ret							// return									

  00163	c3		 ret	 0
$stepD$15:

; 195  : 
; 196  : stepD:
; 197  : 			push esi					// save old esi value

  00164	56		 push	 esi

; 198  : 			push ebx					// save old ebx value

  00165	53		 push	 ebx

; 199  : 			push ecx					// save old ecx

  00166	51		 push	 ecx

; 200  : 			xor ecx,ecx					// set ecx to 0

  00167	33 c9		 xor	 ecx, ecx

; 201  : 			xor ebx,ebx					// set ebx to 0

  00169	33 db		 xor	 ebx, ebx

; 202  : 			mov cl,al

  0016b	8a c8		 mov	 cl, al

; 203  : 			lea esi, gEncodeTable		// put the address of the first byte of gEncodeTable into esi

  0016d	8d 35 00 00 00
	00		 lea	 esi, OFFSET ?gEncodeTable@@3PAEA

; 204  : 			mov bl, byte ptr[esi+ecx]	// copy the value at the index al from gEncodeTable (gEncodeTable[al])

  00173	8a 1c 0e	 mov	 bl, BYTE PTR [esi+ecx]

; 205  : 			mov al,bl					// al is now the table swapped byte

  00176	8a c3		 mov	 al, bl

; 206  : 			pop ecx						// resetore ecx

  00178	59		 pop	 ecx

; 207  : 			pop ebx						// restore ebx

  00179	5b		 pop	 ebx

; 208  : 			pop esi						// restore esi

  0017a	5e		 pop	 esi

; 209  : 			ret							// return

  0017b	c3		 ret	 0
$stepE$16:

; 210  : 
; 211  : stepE:
; 212  : 			push ebx					// save old ebx value

  0017c	53		 push	 ebx

; 213  : 			push ecx					// save old ecx value

  0017d	51		 push	 ecx

; 214  : 			xor ebx,ebx					// set ebx to 0, will be our counter

  0017e	33 db		 xor	 ebx, ebx

; 215  : 			xor ecx,ecx					// set ecx to 0, will be the new reversed value

  00180	33 c9		 xor	 ecx, ecx

; 216  : 			jmp lbl_ELOOP				// start looping

  00182	eb 00		 jmp	 SHORT $lbl_ELOOP$20
$lbl_ELOOP$20:

; 217  : 			
; 218  : 	lbl_ELOOP:
; 219  : 			shl al,1					// shift the right most bit into the carry

  00184	d0 e0		 shl	 al, 1

; 220  : 			rcr cl,1					// rotate the carry into cl

  00186	d0 d9		 rcr	 cl, 1

; 221  : 			cmp ebx,7					// compare counter to 7

  00188	83 fb 07	 cmp	 ebx, 7

; 222  : 			je lbl_EEND					// if counter is 7 end the loop

  0018b	74 03		 je	 SHORT $lbl_EEND$21

; 223  : 			inc ebx						// else increment count

  0018d	43		 inc	 ebx

; 224  : 			jmp lbl_ELOOP				// and keep looping

  0018e	eb f4		 jmp	 SHORT $lbl_ELOOP$20
$lbl_EEND$21:

; 225  : 
; 226  : 	lbl_EEND:
; 227  : 			mov al,cl		// move result into parameter

  00190	8a c1		 mov	 al, cl

; 228  : 			pop ecx						// restore ecx

  00192	59		 pop	 ecx

; 229  : 			pop ebx						// restore ebx

  00193	5b		 pop	 ebx

; 230  : 			ret							// return

  00194	c3		 ret	 0
$lbl_EXIT_ROUNDS$7:

; 231  : 
; 232  : lbl_EXIT_ROUNDS:	
; 233  : 
; 234  : 	}
; 235  : 
; 236  : 	return resulti;

  00195	8b 45 f8	 mov	 eax, DWORD PTR _resulti$[ebp]

; 237  : } // encryptData

  00198	5f		 pop	 edi
  00199	5e		 pop	 esi
  0019a	5b		 pop	 ebx
  0019b	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  001a1	3b ec		 cmp	 ebp, esp
  001a3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001a8	8b e5		 mov	 esp, ebp
  001aa	5d		 pop	 ebp
  001ab	c3		 ret	 0
?encryptData@@YAHPADH@Z ENDP				; encryptData
_TEXT	ENDS
END
