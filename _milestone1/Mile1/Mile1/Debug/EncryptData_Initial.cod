; Listing generated by Microsoft (R) Optimizing Compiler Version 19.15.26732.1 

	TITLE	C:\Users\caleb\OneDrive - University of Texas at San Antonio\Workspace\git\cmp_org_T18-Encryptor-Decryptor-\_milestone1\Mile1\Mile1\EncryptData_Initial.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__7C512EE2_ctype@h DB 01H
__5BEBA810_basetsd@h DB 01H
__07523DAF_corecrt_memcpy_s@h DB 01H
__9F081559_corecrt_memory@h DB 01H
__9CE3A74D_corecrt_wstring@h DB 01H
__78F4D6C6_string@h DB 01H
__F7698904_guiddef@h DB 01H
__1D5C983A_winnt@h DB 01H
__4D75C327_processthreadsapi@h DB 01H
__A1C010E7_memoryapi@h DB 01H
__3CD9AC13_winerror@h DB 01H
__7D6EA4B0_winbase@h DB 01H
__1586EFC7_winuser@h DB 01H
__ED00179D_winioctl@h DB 01H
__FE874262_stdlib@h DB 01H
__22D85348_propidl@h DB 01H
__A325E0C4_oleauto@h DB 01H
__49821EBB_stralign@h DB 01H
__320E01E0_corecrt_stdio_config@h DB 01H
__BAC7FC50_corecrt_wstdio@h DB 01H
__A3797CDC_stdio@h DB 01H
__BE076D93_corecrt_wio@h DB 01H
__CEEB45E5_corecrt_io@h DB 01H
__043F28F7_encryptdata_initial@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?encryptData@@YAHPADH@Z				; encryptData
PUBLIC	__JustMyCode_Default
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	?gptrKey@@3PAEA:DWORD				; gptrKey
EXTRN	?gptrPasswordHash@@3PAEA:DWORD			; gptrPasswordHash
EXTRN	?gdebug1@@3EA:BYTE				; gdebug1
EXTRN	?gdebug2@@3EA:BYTE				; gdebug2
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\caleb\onedrive - university of texas at san antonio\workspace\git\cmp_org_t18-encryptor-decryptor-\_milestone1\mile1\mile1\encryptdata_initial.cpp
;	COMDAT ?encryptData@@YAHPADH@Z
_TEXT	SEGMENT
_resulti$ = -8						; size = 4
_data$ = 8						; size = 4
_dataLength$ = 12					; size = 4
?encryptData@@YAHPADH@Z PROC				; encryptData, COMDAT

; 11   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 12   : 	int resulti = 0;

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _resulti$[ebp], 0

; 13   : 
; 14   : 	gdebug1 = 0;					// a couple of global variables that could be used for debugging

  00025	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?gdebug1@@3EA, 0 ; gdebug1

; 15   : 	gdebug2 = 0;					// also can have a breakpoint in C code

  0002c	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?gdebug2@@3EA, 0 ; gdebug2

; 16   : 
; 17   : 	// You can not declare any local variables in C, but should use resulti to indicate any errors
; 18   : 	// Set up the stack frame and assign variables in assembly if you need to do so
; 19   : 	// access the parameters BEFORE setting up your own stack frame
; 20   : 	// Also, you cannot use a lot of global variables - work with registers
; 21   : 
; 22   : 	__asm {
; 23   : 		//calculate starting index for keyfile starting_index = gPasswordHash[0] * 256 + gPasswordHash[1]
; 24   : 		mov esi, gptrPasswordHash	// put address of gPasswordHas into esi

  00033	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gptrPasswordHash@@3PAEA ; gptrPasswordHash

; 25   : 		xor eax, eax

  00039	33 c0		 xor	 eax, eax

; 26   : 		mov al, byte ptr[esi]		// store gPassword[0] in al

  0003b	8a 06		 mov	 al, BYTE PTR [esi]

; 27   : 		mov bl, 256

  0003d	b3 00		 mov	 bl, 0

; 28   : 		mul bl						// multiply al by 256

  0003f	f6 e3		 mul	 bl

; 29   : 		add al, byte ptr[esi + 1]	// add gPassword[1] to al, al is now starting index for keyfile

  00041	02 46 01	 add	 al, BYTE PTR [esi+1]

; 30   : 		// al is now our value to xor with the data
; 31   : 
; 32   :         //make sure length isnt <=0
; 33   :         xor ebx,ebx					// ebx will be loop control

  00044	33 db		 xor	 ebx, ebx

; 34   :         mov ecx,dataLength			// ecx will be length

  00046	8b 4d 0c	 mov	 ecx, DWORD PTR _dataLength$[ebp]

; 35   :         cmp ecx,0					// check that length is not <= 0

  00049	83 f9 00	 cmp	 ecx, 0

; 36   : 		sub ecx,1					// decrement ecx since non-inclusive length

  0004c	83 e9 01	 sub	 ecx, 1

; 37   :         jbe lbl_EXIT_ZERO_LENGTH

  0004f	76 1b		 jbe	 SHORT $lbl_EXIT_ZERO_LENGTH$3

; 38   :         
; 39   :         //set up the loop
; 40   :         mov edi,data				// put address of first byte of data in edi

  00051	8b 7d 08	 mov	 edi, DWORD PTR _data$[ebp]

; 41   :         mov esi,gptrKey				// put address of gKey into esi

  00054	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gptrKey@@3PAEA ; gptrKey
$lbl_LOOP$4:

; 42   :         //add esi,eax				// set esi to gKey[al]; al is starting_index
; 43   : 
; 44   :         //start looping through data
; 45   : lbl_LOOP:
; 46   :         mov dl,byte ptr[edi + ebx]	// dl is now value of data[ebx]

  0005a	8a 14 1f	 mov	 dl, BYTE PTR [edi+ebx]

; 47   :         xor dl,byte ptr[esi+eax]	// xor dl with the keyfile byte

  0005d	32 14 06	 xor	 dl, BYTE PTR [esi+eax]

; 48   :         mov byte ptr[edi + ebx],dl	// copy dl back into data[ebx]

  00060	88 14 1f	 mov	 BYTE PTR [edi+ebx], dl

; 49   :         add ebx,1					// increment counter ebx

  00063	83 c3 01	 add	 ebx, 1

; 50   :         cmp ebx,ecx					// check havent hit end of data

  00066	3b d9		 cmp	 ebx, ecx

; 51   :         ja lbl_EXIT_END

  00068	77 07		 ja	 SHORT $lbl_EXIT_END$5

; 52   :         jmp lbl_LOOP				// otherwise keep looping

  0006a	eb ee		 jmp	 SHORT $lbl_LOOP$4
$lbl_EXIT_ZERO_LENGTH$3:

; 53   :         
; 54   : lbl_EXIT_ZERO_LENGTH:
; 55   :         sub ebx,1					// decrement ebx to -1 to return failure

  0006c	83 eb 01	 sub	 ebx, 1

; 56   :         jmp lbl_EXIT

  0006f	eb 00		 jmp	 SHORT $lbl_EXIT$6
$lbl_EXIT_END$5:
$lbl_EXIT$6:

; 57   : lbl_EXIT_END:
; 58   : lbl_EXIT:
; 59   :         ret

  00071	c3		 ret	 0

; 60   : 	}
; 61   : 
; 62   : 	return resulti;

  00072	8b 45 f8	 mov	 eax, DWORD PTR _resulti$[ebp]

; 63   : } // encryptData

  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx
  00078	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0007e	3b ec		 cmp	 ebp, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
?encryptData@@YAHPADH@Z ENDP				; encryptData
_TEXT	ENDS
END
